use.miden::account
use.miden::note
use.std::sys

const.ALREADY_INITIALIZED="Already Initialized"
const.NOT_INITIALIZED="Contract not initialized"
const.OWNER_SUFFIX_MISMATCH="Owner suffix mismatch"
const.OWNER_PREFIX_MISMATCH="Owner prefix mismatch"
const.NAME_ALREADY_REGISTERED="Name already registered"
const.ACCOUNT_ALREADY_HAS_NAME="Account already has name"
const.VALIDATE_SUB_OVERFLOW="Payment validation overflow"
const.WRONG_AMOUNT_PAID="Paid amount low"

# Storage
# 0: Initialized flag
# 1: Owner
# 2: Payment Token
# 3: Name -> ID map
# 4: ID -> Name map
# 5: Price

# Input: [PRICE, token_prefix, token_suffix]
# Output: []
export.init
    debug.stack
    exec._assert_initialized
    # [PRICE, token_prefix, token_suffix]
    exec._set_initialized
    # [PRICE, token_prefix, token_suffix]
    exec._set_price
    # [token_prefix, token_suffix]
    exec.note::get_sender
    # [owner_prefix, owner_suffix, token_prefix, token_suffix]
    exec._update_owner
    # [token_prefix, token_suffix]
    exec._set_payment_token
end

# Input: [NAME]
# Output: []
export.register_name
    dupw
    # [NAME, NAME]
    exec._assert_name_not_registered
    # [NAME]
    exec.note::get_sender
    # [prefix, suffix, NAME]
    exec._assert_not_have_name
    # [NAME]
    exec.note::get_sender
    # [prefix, suffix, NAME]
    exec._update_registry
    # []
end


# Input: [NAME]
# Output: [1 or 0, VALUE, ZERO_WORD]
export.is_name_registered
    push.3
    # [3, NAME]
    exec.account::get_map_item
    # [VALUE]
    push.0.0.0.0
    # [ZERO_WORD, VALUE]
    eqw
    # [1 or 0] - 1 if value equals zero (not registered), 0 if value exists (registered)
    not
    # [0 or 1] - 0 if not registered, 1 if registered
end

# Input: [addr_prefix, addr_suffix]
# Output: [NAME]
export.get_name
    exec._get_name_by_addr
end

# Input: [addr_prefix, addr_suffix]
# Output: [1 or 0, ZERO_WORD, NAME]
export.has_name
    exec._get_name_by_addr
    # [NAME]
    push.0.0.0.0
    # [ZERO_WORD, NAME]
    eqw
    # [1 or 0] - 1 if NAME equals zero (no name), 0 if NAME exists (has name)
    not
    # [0 or 1] - 0 if no name, 1 if has name
end

# Input: [prefix, suffix, NAME]
# Output: []
proc._update_registry
    push.0.0
    # [ADDR, NAME]
    dupw.1
    # [NAME, ADDR, NAME]
    dupw.1
    # [ADDR, NAME, ADDR, NAME]
    push.4
    # [4, ADDR, NAME, ADDR, NAME]
    exec.account::set_map_item
    # [OLD_ROOT, OLD_VAL, ADDR, NAME]
    dropw dropw
    # [ADDR, NAME]
    swapw
    # [NAME, ADDR]
    push.3
    # [3, NAME, ADDR]
    exec.account::set_map_item
    # [OLD_ROOT, OLD_VAL]
    dropw dropw
end

# Input: [addr_prefix, addr_suffix]
# Output: [NAME]
proc._get_name_by_addr
    push.0.0
    # [0, 0, addr_prefix, addr_suffix]
    push.4
    # [4, 0, 0, addr_prefix, addr_suffix]
    exec.account::get_map_item
    # [VALUE]
end

# Input: [NAME]
# Output: []
proc._assert_name_not_registered
    push.3
    # [3, NAME]
    exec.account::get_map_item
    # [VALUE]
    push.0.0.0.0
    # [ZERO_WORD, VALUE]
    eqw
    # [1 or 0] - 1 if VALUE equals ZERO_WORD (name not registered), 0 if different (name registered)
    assert.err=NAME_ALREADY_REGISTERED
    # [] - assertion passes if name is not registered (eqw returned 1)
    # []
end

# Input: [prefix, suffix]
# Output: []
proc._assert_not_have_name
    push.0.0
    push.4
    exec.account::get_map_item
    # [VALUE]
    push.0.0.0.0
    # [ZERO_WORD, VALUE]
    eqw
    # [1 or 0] - 1 if VALUE equals ZERO_WORD (no name), 0 if different (has name)
    assert.err=ACCOUNT_ALREADY_HAS_NAME
    # [] - assertion passes if account has no name (eqw returned 1)
end


# Input: []
# Output: []
proc._assert_initialized
    push.0
    # [0]
    exec.account::get_item
    assertz.err=ALREADY_INITIALIZED
    # [INITIALIZED_FLAG]
    drop drop drop
    # [initialized_flag]
   
    # []
end

# Input: []
# Output: []
proc._set_initialized
    push.0.0.0.1
    # [0, 0, 0, 1]
    push.0
    # [0, 0, 0, 0, 1]
    exec.account::set_item
    # [OLD_WORD]
    dropw
end

# Input: [PRICE]
# Output: []
proc._set_price
    push.5
    # [5, PRICE]
    exec.account::set_item
    # [OLD_VALUE]
    dropw
end

# Input: []
# Output: [PRICE]
proc._get_price_word
    push.5
    # [5]
    exec.account::get_item
    # [PRICE]
end

# Input: [owner_prefix, owner_suffix]
# Output: []
proc._update_owner
    push.0.0
    # [0, 0, owner_prefix, owner_suffix]
    push.1
    # [1, 0, 0, owner_prefix, owner_suffix]
    exec.account::set_item
    # [OLD_VALUE]
    dropw
end

# Input: []
# Output: []
proc._assert_only_owner
    exec.note::get_sender
    # [sender_prefix, sender_suffix]
    push.1
    # [1, sender_prefix, sender_suffix]
    exec.account::get_item
    # [OWNER_WORD, sender_prefix, sender_suffix]
    drop drop
    # [owner_prefix, owner_suffix, sender_prefix, sender_suffix]
    swap.4
    # [sender_suffix, owner_suffix, sender_prefix, owner_prefix]
    assert_eq.err=OWNER_SUFFIX_MISMATCH
    assert_eq.err=OWNER_PREFIX_MISMATCH
    # []
end

# Input: [token_prefix, token_suffix]
# Output: []
proc._set_payment_token
    push.0.0
    # [0, 0, token_prefix, token_suffix]
    push.2
    # [2, 0, 0, token_prefix, token_suffix]
    exec.account::set_item
    dropw
end

# Input: []
# Output: [balance]
proc._get_balance
    push.2
    # [2]
    exec.account::get_item
    # [PAYMENT_TOKEN]
    drop drop
    # [token_prefix, token_suffix]
    exec.account::get_balance
    # [balance]
end

# Input: []
# Output: []
proc._validate_payment
    exec._get_balance
    # [initial_balance]
    exec.note::add_assets_to_account
    # [initial_balance]
    exec._get_balance
    # [after_balance, initial_balance]
    u32overflowing_sub # after - initial
    # [overflow, result]
    assertz.err=VALIDATE_SUB_OVERFLOW
    # [result]
    exec._get_price_word
    # [PRICE, result]
    drop drop drop
    # [price, result]
    lte
    # [price =< result]
    assert.err=WRONG_AMOUNT_PAID
end
