use.miden::account
use.miden::account_id
use.miden::note

## Storage Slots
const.INIT_FLAG_SLOT=0
const.OWNER_SLOT=1
const.PRICES_SLOT=2 # domain prices map([0, letter_count, payment_token_prefix, payment_token_suffix] -> [PRICE])
const.ACCOUNT_ID_TO_DOMAIN_SLOT=3
const.DOMAIN_TO_ACCOUNT_ID_SLOT=4
const.DOMAIN_TO_OWNER_SLOT=5
const.REF_RATE_SLOT=6
const.REF_TOTAL_REVENUE_SLOT=7
const.REF_CLAIMED_REVENUE_SLOT=8
const.DOMAIN_COUNT_SLOT=9
const.TOTAL_REVENUE_SLOT=10 # protocol total revenue map([0, 0, token_prefix, token_suffix] -> amount)
const.CLAIMED_REVENUE_SLOT=11

## Errors
const.ERR_ONLY_OWNER="Only owner"
const.ERR_ONLY_DOMAIN_OWNER="Only domain owner"
const.ERR_ALREADY_INITIALIZED="Contract already initialized"
const.ERR_PAYMENT_TOKEN_NOT_ALLOWED="This payment token not allowed"
const.ERR_PRICE_ZERO="Price zero for this length"
const.ERR_VALIDATE_PAYMENT_SUB_OVERFLOW="Validating payment sub overflow"
const.ERR_INSUFFICIENT_AMOUNT_PAID="Paid amount less that price"
const.ERR_DOMAIN_NOT_AVAILABLE="Domain is already taken"
const.ERR_DOMAIN_LENGTH_TOO_HIGH="21 characters allowed"
const.ERR_REF_RATE_OVERLIMIT="Ref rate higher or equal to 10000"
const.ERR_REF_RATE_TOO_HIGH="Max 2500 ref rate"
const.ERR_REF_RATE_ZERO="Ref rate zero"
const.ERR_REF_NOT_EXIST="Referrer rate is zero"
const.DOMAIN_LENGTH_TOO_HIGH="Maximum 21 characters allowed"
const.ERR_INVALID_DOMAIN_LENGTH="Domain length field does not match actual character count"
const.ERR_EMPTY_DOMAIN="Domain length zero"

## Memory Pointers

const.MEM_DOMAIN=0x0020 # WORD
const.MEM_PAYMENT_TOKEN=0x0024 # WORD
const.MEM_REFERRER=0x0028 # WORD
const.MEM_DOMAIN_NEW_OWNER=0x002C # WORD

## Constants
const.MAX_NAME_LENGTH=21
const.MAX_REF_RATE=10000 # Basis point
const.REF_RATE_LIMIT=2500 # %25
const.DOMAIN_LETTER_PRICE_BREAKPOINT=5 # After 5 letters constant price

const.MAX_FELT_PART=0xFFFFFFFFFFFFFF # 8*7 bits

const.PAD_4TH_CHAR=16777216
const.PAD_3RD_CHAR=65536
const.PAD_2ND_CHAR=256
const.PAD_1ST_CHAR=1

# Input: [PAYMENT_TOKEN, DOMAIN]
# Output: []
export.register
    mem_storew.MEM_PAYMENT_TOKEN dropw
    mem_storew.MEM_DOMAIN dropw
    # []
    exec._assert_domain_available
    exec._assert_domain_rules
    exec._assert_payment_token
    
    exec._calculate_domain_price
    # [price]
    exec._receive_payment
    # []
    # Update domain owner
    exec.note::get_sender
    exec._update_domain_owner
    # []
    # Update domain map
    exec.note::get_sender
    exec._update_domain_map

    exec._calculate_domain_price
    # [price]
    exec._increase_total_revenue

    # []
    exec._after_domain_register
end

# Input: [REFERRER, PAYMENT_TOKEN, DOMAIN]
export.register_with_referrer
    mem_storew.MEM_REFERRER dropw
    mem_storew.MEM_PAYMENT_TOKEN dropw
    mem_storew.MEM_DOMAIN dropw
    # []
    exec._assert_domain_available
    exec._assert_domain_rules
    exec._assert_payment_token

    exec._calculate_domain_price
    # [price]
    exec._receive_payment
    # []
    # Update domain owner
    exec.note::get_sender
    exec._update_domain_owner
    # []
    # Update domain map
    exec.note::get_sender
    exec._update_domain_map

    exec._calculate_domain_price
    # [price]
    exec._register_referrer_revenue
    # [protocol_revenue]
    exec._increase_total_revenue

    exec._after_domain_register
end

# Inputs: [NEW_OWNER, DOMAIN]
export.transfer
    mem_storew.MEM_DOMAIN_NEW_OWNER dropw
    mem_storew.MEM_DOMAIN dropw

    exec._assert_only_domain_owner
    exec._clear_domain_mapping

    padw mem_loadw.MEM_DOMAIN_NEW_OWNER drop drop
    # [NEW_OWNER]
    exec._update_domain_owner
    # []
end

# Input: [OWNER]
export.init
    debug.stack
    push.INIT_FLAG_SLOT exec.account::get_item drop drop drop
    assertz.err=ERR_ALREADY_INITIALIZED
    # [OWNER]
    push.OWNER_SLOT exec.account::set_item dropw
    # []
    push.1.0.0.0 push.INIT_FLAG_SLOT exec.account::set_item dropw
    # []
end

# Input: [ASSET]
# Output: [pad(16)]
export.receive_asset
    exec.account::add_asset
    # => [ASSET', pad(12)]

    # drop the final asset
    dropw
    # => [pad(16)]
end

## Only owner methods

# Input: [NEW_OWNER]
# Output: []
export.update_registry_owner
    exec._assert_only_owner
    # [0, 0, new_owner_prefix, new_owner_suffix]
    push.OWNER_SLOT
    exec.account::set_item
    dropw
end

# Input: [0, letter_count, token_prefix, token_suffix, PRICE]
# Output: []
export.set_price
    exec._assert_only_owner
    push.PRICES_SLOT exec.account::set_map_item dropw dropw
end

## Internal Methods

# Input: [] Memory [DOMAIN]
# Output: []
proc._clear_domain_mapping
    padw mem_loadw.MEM_DOMAIN
    # [DOMAIN]
    push.DOMAIN_TO_ACCOUNT_ID_SLOT exec.account::get_map_item
    # [ACCOUNT]
    padw swapw
    # [ACCOUNT, ZERO]
    push.ACCOUNT_ID_TO_DOMAIN_SLOT exec.account::set_map_item dropw dropw
    # []
    padw mem_loadw.MEM_DOMAIN
    # [DOMAIN]
    padw swapw
    # [DOMAIN, ZERO]
    push.DOMAIN_TO_ACCOUNT_ID_SLOT exec.account::set_map_item dropw dropw
    # []
end

# Input: [total_amt] Memory [PAYMENT_TOKEN, REFERRER]
# Output: [protocol_revenue]
proc._register_referrer_revenue
    # [total_amt]
    padw mem_loadw.MEM_REFERRER
    # [REFERRER, total_amt]
    push.REF_RATE_SLOT exec.account::get_map_item drop drop drop
    # [ref_rate, total_amt]
    dup gt.0 assert.err=ERR_REF_RATE_ZERO
    dup lt.MAX_REF_RATE assert.err=ERR_REF_RATE_OVERLIMIT
    # [ref_rate, total_amt]
    swap dup swap.2
    # [total_amt, ref_rate, total_amt]
    mul div.10000
    # [(rate * total) / 10000, total_amt]
    sub 
    # [total - ((rate * total) / 10000)]
end

# Input: [amt] Memory [PAYMENT_TOKEN]
# Output: []
proc._increase_total_revenue
    padw mem_loadw.MEM_PAYMENT_TOKEN
    push.TOTAL_REVENUE_SLOT exec.account::get_map_item drop drop drop
    # [total_amount, amt]
    add push.0.0.0
    # [FINAL_AMT]
    padw mem_loadw.MEM_PAYMENT_TOKEN
    # [PAYMENT_TOKEN, FINAL_AMT]
    push.TOTAL_REVENUE_SLOT exec.account::set_map_item dropw dropw
    # []
end

# Input: [account_prefix, account_suffix] Memory [DOMAIN]
# Output: []
proc._update_domain_map
    push.0.0 dupw
    # [ACCOUNT, ACCOUNT]
    padw mem_loadw.MEM_DOMAIN
    push.DOMAIN_TO_ACCOUNT_ID_SLOT
    exec.account::set_map_item dropw dropw
    # [ACCOUNT]
    padw mem_loadw.MEM_DOMAIN swapw
    # [ACCOUNT, DOMAIN]
    push.ACCOUNT_ID_TO_DOMAIN_SLOT
    exec.account::set_map_item dropw dropw
    # []
end

# Input: [new_owner_prefix, new_owner_suffix] Memory [DOMAIN]
# Output: []
proc._update_domain_owner
    push.0.0
    # [0,0, prefix, suffix]
    padw mem_loadw.MEM_DOMAIN
    # [DOMAIN, 0, 0, prefix, suffix]
    push.DOMAIN_TO_OWNER_SLOT
    # [slot, DOMAIN, 0, 0, prefix, suffix]
    exec.account::set_map_item dropw dropw
    # []
end

# Input: []
# Output: []
proc._after_domain_register
    exec._increase_domain_count
end

# Input: []
# Output: []
proc._increase_domain_count
    push.DOMAIN_COUNT_SLOT
    exec.account::get_item drop drop drop
    # [total_supply]
    add.1 push.0.0.0
    # [0, 0, 0, total_supply + 1]
    push.DOMAIN_COUNT_SLOT exec.account::set_item dropw
end

# Input: [] Memory [DOMAIN, PAYMENT_TOKEN]
# Output: [price]
# Call it after validate domain
proc._calculate_domain_price
    padw mem_loadw.MEM_PAYMENT_TOKEN drop drop
    # [prefix, suffix]
    padw mem_loadw.MEM_DOMAIN swap.3 drop drop drop
    # [length, prefix, suffix]
    push.0
    push.PRICES_SLOT exec.account::get_map_item drop drop drop
    # [price]
end

# Input: [] Memory [PAYMENT_TOKEN]
# Output: [balance]
proc._get_balance
    padw mem_loadw.MEM_PAYMENT_TOKEN drop drop
    exec.account::get_balance
    # [balance]
end

# Input: [min_amt] Memory [PAYMENT_TOKEN]
# Output: []
proc._receive_payment
    exec._get_balance
    # [before_bal, min_amt]
    exec.note::add_assets_to_account
    exec._get_balance
    # [after_bal, before_bal, min_amt]
    swap u32overflowing_sub assertz.err=ERR_VALIDATE_PAYMENT_SUB_OVERFLOW
    lte assert.err=ERR_INSUFFICIENT_AMOUNT_PAID
    # []
end

# Input: [] Memory [PAYMENT_TOKEN]
# Output: []
proc._assert_payment_token
    padw mem_loadw.MEM_PAYMENT_TOKEN drop drop
    push.1
    # [letter, prefix, suffix]
    push.0
    # [PRICES_KEY]
    push.PRICES_SLOT
    exec.account::get_map_item drop drop drop
    # [price]
    gt.0 assert.err=ERR_PAYMENT_TOKEN_NOT_ALLOWED
    # []
end

# Input: []
# Output: []
proc._assert_only_owner
    exec.note::get_sender
    # [caller_prefix, caller_suffix]
    push.OWNER_SLOT
    exec.account::get_item
    # [0, 0, owner_prefix, owner_suffix, caller_prefix, caller_suffix]
    drop drop
    # [owner_prefix, owner_suffix, caller_prefix, caller_suffix]
    exec.account_id::is_equal assert.err=ERR_ONLY_OWNER
    # []
end

# Input: [] Memory [DOMAIN]
# Output: []
proc._assert_only_domain_owner
    padw mem_loadw.MEM_DOMAIN
    push.DOMAIN_TO_OWNER_SLOT
    # [slot, DOMAIN]
    exec.account::get_map_item drop drop
    # [owner_prefix, owner_suffix]
    exec.note::get_sender
    # [caller_prefix, caller_suffix, owner_prefix, owner_suffix]
    exec.account_id::is_equal assert.err=ERR_ONLY_DOMAIN_OWNER
    # []
end

# Input: [] Memory [DOMAIN]
# Output: []
proc._assert_domain_available
    padw mem_loadw.MEM_DOMAIN
    push.DOMAIN_TO_OWNER_SLOT
    exec.account::get_map_item drop drop
    push.0.0 exec.account_id::is_equal

    assert.err=ERR_DOMAIN_NOT_AVAILABLE
end

# Input: [] Memory [DOMAIN]
# Output: []
proc._assert_domain_rules
    padw mem_loadw.MEM_DOMAIN
    dupw
    # [DOMAIN, DOMAIN]
    exec._validate_domain_length
    # [DOMAIN]
    lte.MAX_NAME_LENGTH
    # [len_check, f1, f2, f3]
    assert.err=ERR_DOMAIN_LENGTH_TOO_HIGH
    # [f1, f2, f3]
    drop drop drop
end

############################
## Domain length validations
############################

# Input: [] Memory [DOMAIN]
# Output: [length]
proc._get_domain_length
    padw mem_loadw.MEM_DOMAIN
    swap.3 drop drop drop
    # [length]
end

# Input: [length, felt1, felt2, felt3] -> DOMAIN
# Output: []
proc._validate_domain_length
    # Stack: [length, felt1, felt2, felt3]
    dup eq.0 assertz.err=ERR_EMPTY_DOMAIN
    movdn.3
    # [f1, f2, f3, length]
    exec._count_chars_in_felt
    # [f1_count, f2, f3, length]
    movdn.2
    # [f2, f3, f1_count, length]
    exec._count_chars_in_felt swap
    # [f3, f2_count, f1_count, length]
    exec._count_chars_in_felt
    # [f3_count, f2_count, f1_count, length]
    add add 
    # [f3+f2+f1, length]
    eq
    # [1 or 0]
    assert.err=ERR_INVALID_DOMAIN_LENGTH
end

# Input: [felt]
# Output: [count]
proc._count_chars_in_felt
    u32split
    # [u32_high, u32_low]
    exec._count_chars_in_u32
    # [count_high, u32_low]
    swap
    exec._count_chars_in_u32
    # [count_low, count_high]
    add
    # [count]
end

# Input: [u32]
# Output: [count]
proc._count_chars_in_u32
    push.0 swap # push count
    # [u32, count]
    u32divmod.PAD_4TH_CHAR swap
    # [bolum, kalan, count]
    gt.0
    if.true
        # [kalan, count]
        swap 
        # [count, kalan]
        add.1 swap
        # [kalan, count + 1]
    end

    u32divmod.PAD_3RD_CHAR swap
    gt.0
    if.true
        # [kalan, count]
        swap 
        # [count, kalan]
        add.1 swap
        # [kalan, count + 1]
    end
    u32divmod.PAD_2ND_CHAR swap
    gt.0
    if.true
        swap add.1 swap
    end

    u32divmod.PAD_1ST_CHAR swap
    gt.0
    if.true
        swap add.1 swap
    end
    drop
end